<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script src="./ort.min.js"></script>
    <script src="./jimp.min.js"></script>
    <script>
        ort.env.wasm.wasmPaths = "https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/";

        // this reads from url. to read from file eventually: https://github.com/jimp-dev/jimp/issues/842
        async function main() {
            console.log("1. Loading image...");
            const image = await Jimp.read("/clear.jpg");

            console.log("2. Processing image...");
            image.resize(480, 640);
            const imageData = image.bitmap.data; // rgba array
            const imageTensor = imageToTensor(imageData, [1, 3, 480, 640]);
            console.log(imageTensor);

            console.log("3. Initializing session...");
            const session = await ort.InferenceSession.create("./version-RFB-640.onnx");

            console.log("4. Running inference...");
            const output = await session.run({input: imageTensor});

            console.log(output);
        }

        // adapted from https://onnxruntime.ai/docs/tutorials/web/classify-images-nextjs-github-template.html
        // dims: number[] => Tensor
        function imageToTensor(imageData, dims) {
            const [redArray, greenArray, blueArray] = new Array(new Array(), new Array(), new Array());

            for (let i = 0; i < imageData.length; i += 4) {
                redArray.push(imageData[i]);
                greenArray.push(imageData[i + 1]);
                blueArray.push(imageData[i + 2]);
                // skip data[i + 3] to filter out the alpha channel
            }

            const transposedData = redArray.concat(greenArray).concat(blueArray);

            let i, l = transposedData.length;

            const float32Data = new Float32Array(dims[1] * dims[2] * dims[3]);
            for (i = 0; i < l; i++) {
                float32Data[i] = transposedData[i] / 255.0;
            }

            const inputTensor = new ort.Tensor("float32", float32Data, dims);
            return inputTensor;
        }

        main();
    </script>
</body>
</html>